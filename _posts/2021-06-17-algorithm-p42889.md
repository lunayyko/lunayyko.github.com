---
layout: post
category: 알고리즘
tag: [기초, 프로그래머스, 나중에 살펴보기, 내용 추가하기, 질문]
title: 프로그래머스 level 1 실패율 06.17 TIL
---

[실패율](https://programmers.co.kr/learn/courses/30/lessons/42889) 

## 문제 설명

슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.

이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.

실패율은 다음과 같이 정의한다.
스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수
전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.

## 입출력 예

<table>
  <thead>
    <tr>
      <th>n</th>
      <th>stages</th>
      <th>result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>[2, 1, 2, 6, 2, 4, 3, 3]</td>
      <td>[3,4,2,1,5]</td>
    </tr>
    <tr>
      <td>4</td>
      <td>[4,4,4,4,4]</td>
      <td>[4,1,2,3]</td>
    </tr>
  </tbody>
</table>

## 사고 과정

```python
def solution(n, stages):
    
    fail_rates = {} #실패율
    trying_num = 0 #도전 중인 사람들의 수
    cleared = {} #클리어한 사람들
    cleared_num = 0 #클리어한 사람들의 수
    
    for n in range(1,n+1):
    # n : 현재 스테이지 (1~6)
        trying_num = stages.count(n)
        # 도전 중인 사람들의 수 : 스테이지 배열에서 n의 갯수 
        for j in stages:
            if j > n:
                cleared.append(n)
        # 클리어한 사람들의 수 : 스테이지 배열에서 n보다 큰 숫자의 갯수
        cleared_num = cleared()    
    fail_rates.append(tried_num/trying_num * 100)
    # 실패율 : 도전 중인 사람들의 수 / 클리어한 사람들의 수 * 100
    
    for pair in zip(range(1,n+1), fail_rates):
    # 1부터N까지의 리스트와 fail_rates배열을 대응시켜서 
    
    # 높은 순서대로 보여준다?
    return(pair)
```
이렇게 생각을 하고 3시간정도 고민했는데 답이 나오지 않아서 인터넷에 검색해봤더니  
클리어한 사람들의 수를 구하지 않고 실패한 사람의 수 / 스테이지에 도달한 사람의 수로 계산한 것을 볼 수 있었다. 그래서 그렇게 다시 고쳐서 써봤다.

## 사고 과정

```python
def solution(n, stages):
    
    list_n = range(1,n+1)
    fail_rates = []
    failed_user = 0 # 실패한 사람의 수
    total_user = len(stages) 
    #전체 사용자의 수 : 실패한 사람들을 빼서 스테이지에 도달한 사람의 수로 사용    
    
    for n in list_n:
        if total_user == 0:
            #전체 사용자가 0이면 실패율0
            fail_rates.append(0)
        else:
            failed_user = stages.count(n)
            # 실패한 사람의 수 : 스테이지 배열에서 n의 갯수
            fail_rates.append(failed_user/total_user * 100)
            # 실패율 : 실패한 사람들의 수 / 스테이지에 도달한 사람의 수 * 100
            total_user -= failed_user
            # 전체 사용자의 수에서 실패한 사람들의 수를 뺀다
    print(fail_rates)
    
    pair = list(zip(list_n, fail_rates))
    # 1부터N까지의 리스트와 fail_rates배열을 대응시켜서 
    answer = 
    # 높은 순서대로 보여준다..?
    return answer
```
이렇게 고쳐서 스테이지별 실패율의 딕셔너리를 리스트로 출력하는것까지는 나왔다.  
[(1, 12.5), (2, 42.857142857142854), (3, 50.0), (4, 50.0), (5, 0.0)]   

이 딕셔너리의 값에 있는 실패율을 내림차순 정렬하고 키값을 반환하려면
아래와 같이 람다라는걸 사용해야 되는 것 같다. 

```python
sorted(pair, key=lambda x : pair[x], reverse=True)
```
실행했더니  
TypeError: list indices must be integers or slices, not tuple
리스트의 인수들이 튜플이 아닌 정수형이나 슬라이스여야한다는 에러가 나왔다.  

이 부분을 몇 번 수정해봤는데 모르는 개념이라서 그런지 계속 에러가 나온다.
'NoneType' object is not iterable

```python
    pair = list(zip(list_n, fail_rates))
    # 1부터N까지의 리스트와 fail_rates배열을 대응시켜서 높은 순서대로 보여준다
    pair_sorted = pair.sort(key=lambda x:x[1], reverse=True)
    # 실패율 역순 정렬 
    return [stage for stage,percentage in pair_sorted] 
    # 실패율 딕셔너리에서 스테이지 번호만 뽑아서 반환
```
딕셔너리를 밸류 기준으로 정렬해서 딕셔너리의 키값만 반환화는 부분을 좀 더 공부하고 다시 풀어봐야겠다.

## 모범 답안

```python
def solution(N, stages):
    fail_rate = {}
    total_user = len(stages)

    for stage in range(1, N+1):
        if total_user != 0:
            fail_user = stages.count(stage)
            fail_rate[stage] = fail_user / total_user
            #여기서는 zip이 아닌 arr1[arr2]를 사용했다
            total_user -= fail_user
        else:
            fail_rate[stage] = 0

    return sorted(fail_rate, key=lambda x : fail_rate[x], reverse=True)
```

* 주요 포인트 및 생각해볼 점   

arr1\[arr2]로 딕셔너리를 만드는 방법  
딕셔너리를 밸류 기준으로 정렬하는법  
딕셔너리의 키값만 반환하는 법

