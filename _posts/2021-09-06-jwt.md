---
layout: post
category: django
tag: [입문, TIL]
title: 로그인 - jwt, Redis, stateless vs stateful, cookie vs session 
---

회원가입/로그인이 이루어질 때 jwt를 발급하고 이를 통해 유저를 알아본다는 것까지 학원에서 실습 및 구현을 했었다. 기업협업 중에 admin/superadmin 데코레이터를 만드는데 pay_load에 넣은 role이 반영되지 않아서 하루동안 고민했는데 사수분께서 pay_load에 뭔가 새로 추가했으면 엑세스토큰을 다시 발급받았어야된다면서 jwt의 구성요소에 대해서 설명해주고 아래 개념들에 대해서 공부해보라고 하셨다.

참고로 첨부하는 admin_only 데코레이터
```python
def admin_only(func):
    def wrapper(self, request, *args, **kwargs):
        try:
            access_token = request.headers.get('Authorization')
            pay_load     = jwt.decode(access_token, SECRET_KEY, algorithms=[ALGORITHM])
            role         = pay_load['role']
            user         = User.objects.get(id=pay_load['user_id'])
            request.user = user
            
            if not role == 'admin':
                return JsonResponse({'message': 'UNAUTHORIZED'}, status=401)

            return func(self, request, *args, **kwargs)

        except jwt.InvalidTokenError:
            return JsonResponse({'message': 'INVALID_TOKEN'}, status=401)
        except jwt.exceptions.DecodeError:
            return JsonResponse({'message': 'DECODE_ERROR'}, status=400)
        except jwt.ExpiredSignatureError:
            return JsonResponse({'message': 'EXPIRED_TOKEN'}, status=401)
        except User.DoesNotExist:
            return JsonResponse({'message': 'USER_DOES_NOT_EXISTS'}, status=401)
        except KeyError:
            return JsonResponse({'message': 'KEY_ERROR'}, status=400)
```

## jwt

json web token은 아래와 같은 구성요소로 이루어져 있다. 
![jwt구성요소](/public/img/jwt.png)
[출처 : https://jwt.io/](https://jwt.io/)

토큰을 디코딩해보고 싶을 때는 위의 사이트 혹은 아래에서 해봐도 된다.
[출처 : https://www.base64decode.org/](https://www.base64decode.org/)

## stateless vs stateful

서버가 클라이언트(사용자)의 정보를 저장하느냐 아니냐에 따라 stateful(상태유지)와 stateless(무상태)로 나눌 수 있다. 이 블로그의 자전거를 구매하는 대화의 예시를 통해 무상태와 상태유지의 차이를 쉽게 알 수 있다! [출처: irostub 블로그](https://irostub.github.io/web/stateful-stateless/) 

예를 들어서 무상태는 서버가 아무것도 기억하지 않고 클라이언트가 요청하고싶은 사항을 모아서 전달하는 것이고 상태유지는 클라이언트가 전에 했던 요청을 서버가 다 기억하고 있는 것이다.

무상태는 클라이언트의 요청으로 더 많은 데이터를 소모하지만 서버의 확장성이 높고 상대적으로 특별한 일이 없다면 무상태를 지향해야한다. 

## Redis

한 마디로 메모리를 이용하여 고속으로 <\key, value> 스타일의 데이터를 저장하고 불러올 수 있는 시스템이라고 할 수 있다. 2009년 살바토르 산필리포가 개발한 오픈 소스 기반 비관계형 데이터베이스 관리 시스템으로 데이터베이스를 쓸 때 입출력에 시간이 걸리기 때문에 메모리 기반의 저장소에 캐시처럼 정보를 저장해놓고 빠르게 입출력할 수 있도록 만든 것이다.

MySQL보다 10배 빠를 수 있지만 메모리는 휘발성이기때문에 시스템이 꺼지면 모든 데이터는 날아가므로 Redis는 임시 데이터를 저장하는데 사용한다. 

## Cookie, Session

상태정보를 클라이언트에 저장하는 방식이 쿠키이고 웹 서버에 저장하는 방식이 세션이다.
작고 귀여운 정보는 쿠키에 저장하고 보안이 필요한 경우에는 세션으로 저장한다. 

![쿠키와 세션](/public/img/session.png)

### 쿠키

- 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성되어 있다.
- 클라이언트에 총 300개의 쿠키를 저장할 수 있다, 도메인 당 20개의 쿠키를 가질 수 있다
- 하나의 쿠키는 4KB(=4096byte)까지 저장 가능하다.

쿠키 사용 예시로는 방문했던 사이트에 다시 방문 하였을 때 아이디와 비밀번호 자동 입력, "오늘 이 창을 다시 보지 않기" 체크가 있다. 

### 세션

- 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장한다, 웹 서버의 저장되는 쿠키(=세션 쿠키)
- 브라우저를 닫거나, 서버에서 세션을 삭제했을때만 삭제가 되므로 쿠키보다 비교적 보안이 좋다.
- 각 클라이언트 고유 Session ID를 부여한다, Session ID로 클라이언트를 구분하여 각 클라이언트 요구에 맞는 서비스 제공한다.

화면이 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지하는 것이 세션이다.

